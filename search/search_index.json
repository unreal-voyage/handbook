{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Unreal Engine 5 Handbook","text":"<p>Welcome to the Unreal Engine 5 Handbook, a collaborative effort dedicated to providing comprehensive and user-friendly documentation for Unreal Engine 5, in the hope of making Unreal more accessible to all developers.</p> <p>You can browse through the Manuals section to find in-depth looks into individual features and elements  of Unreal Engine 5, or check out the Tutorials section for step-by-step guides on how to  go about a specific task.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We certainly appreciate all the help we can get! \u2764\ufe0f</p> <p>This project is openly accessible on GitHub. Please fork the repository,  and create a pull request for anything you'd like to add. You can also create issues for any mistakes you have  found in the documentation.</p>"},{"location":"nav/","title":"Nav","text":"<ul> <li>Manuals<ul> <li>Player<ul> <li>Input</li> </ul> </li> </ul> </li> <li>Tutorials</li> </ul>"},{"location":"player/input/","title":"Player Input","text":"<p>The Player Input class is responsible for processing hardware input from the player and passing the signals to the Player Controller to then trigger events bound to move the pawn, fire a weapon, or perform any other action.</p> <p>In the past, the <code>UPlayerInput</code> class was used to handle player input, which could trigger special events for the Input Actions and Input Axis defined in the Project Settings (Engine \u2192 Input). This approach, however, is now deprecated in favor of the  Enhanced Input Plugin which implements <code>UEnhancedPlayerInput</code>. Enhanced Input offers a number of advantages over the legacy system, and implements features such as radial dead  zones, contextual input, and prioritization, as well as the ability to remap the controls at runtime with ease.</p> <p>Unreal Engine comes bundled with two more input plugins, which are also worth mentioning. The  Raw Input Plugin can be used to add support for specific devices that aren't properly handled by Microsoft's XInput API. Flight sticks  and steering wheels fall into this category. There is also the  Force Feedback Plugin,  which would allow you to add rumble to gamepads and controllers.</p>"},{"location":"player/input/#enhanced-input-plugin","title":"Enhanced Input Plugin","text":"<p>The plugin is enabled by default in the recent versions of Unreal Engine. Its associated classes should also be set as  the default for Player Input and Input Component in the Project Settings (Engine \u2192 Input).</p> <p></p> <p>Now, if you right-click in the Content Browser, you should see the following options under Input:</p> <p>Let us now take a look at the core elements of Enhanced Input.</p>"},{"location":"player/input/#input-actions","title":"Input Actions","text":"<p>In Enhanced Input, every action that can be triggered by the player, such as moving in the world, looking around,  firing a weapon, and jumping, should be represented via an Input Action, simple data assets with a handful of attributes.</p> <p>The most important attribute of an Input Action is its Value Type, which can be:</p> <ul> <li>Digital: Represented as a <code>Boolean</code> value, and commonly used for actions that have an      On/Off state. E.g., pressing a button to pick up item could be represented as a Digital action.</li> <li>Axis1D: Represented as a <code>Float</code> value, and commonly used for actions that have a range      of values. An example would be using the middle mouse button to zoom in and out.</li> <li>Axis2D: Represented as a <code>Vector2D</code> value. Axis2D can be helpful when representing      actions such as moving or looking around.</li> <li>Axis3D: Represented as a <code>Vector</code> value. Axis3D is less common, but it can be used to      hold more complex data, such as motion controller information.</li> </ul> <p>After deciding how you'd like to represent an action, you may want to use Modifiers and Triggers to your  Input Actions, to further control how it processes user input and how the action reacts.</p>"},{"location":"player/input/#modifiers","title":"Modifiers","text":"<p>Modifiers are preprocessors that alter the raw input values that the engine receives before sending them out. They  can be useful for applying sensitivity settings, smoothing input over multiple frames, or changing how input behaves  based on the state of the player.</p> <p>You can define your own Modifiers by inheriting from the <code>UInputModifier</code>  class, and overriding the <code>ModifyRaw()</code> RPC, in either Blueprints or C++. Below is an example of a Modifier used in  the Lyra Game Sample. </p> <pre><code>/* Applies an inversion of axis values based on a setting in the Lyra Shared game settings. */\n\nUCLASS(NotBlueprintable, MinimalAPI, meta = (DisplayName = \"Lyra Aim Inversion Setting\"))\nclass ULyraInputModifierAimInversion : public UInputModifier {\n    GENERATED_BODY()\n\npublic:\n\n    // Custom parameters will show up in the Input Action editor.\n    UPROPERTY(EditInstanceOnly, BlueprintReadWrite, Category=Settings, Config)\n    bool bInvertVerticalAxis = false;\n\nprotected:\n\n    virtual FInputActionValue ModifyRaw_Implementation(const UEnhancedPlayerInput* PlayerInput, FInputActionValue CurrentValue, float DeltaTime) override {\n        {\n            ULyraLocalPlayer* LocalPlayer = LyraInputModifiersHelpers::GetLocalPlayer(PlayerInput);\n            if (!LocalPlayer) {\n                return CurrentValue;\n            }\n            ULyraSettingsShared* Settings = LocalPlayer-&gt;GetSharedSettings();\n            FVector NewValue = CurrentValue.Get&lt;FVector&gt;();\n            if (bInvertVerticalAxis) {\n                NewValue.Y *= -1.0f;\n            }\n            if (Settings-&gt;GetInvertHorizontalAxis()) {\n                NewValue.X *= -1.0f;\n            }\n            return NewValue;\n        }\n    }\n};\n</code></pre>"},{"location":"player/input/#bundled","title":"Bundled","text":"<p>The Enhanced Input Plugin comes bundled with a variety of Modifiers to perform common preprocessing tasks. The full list is shown below.</p> Modifier Description Deadzone Input values within the range <code>LowerThreshold</code> - <code>UpperThreshold</code> will be remapped from 0-1. Values outside this range will be clamped. FOV Scaling Apply FOV dependent scaling to input values, per axis. Negate Inverts input per axis. Response Curve Apply a user-defined response curve to input values, per axis. Scalar Scales input by specified factor. Scale By Delta Time Multiplies the input by <code>DeltaTime</code>. Smooth Smooths the input over multiple frame. Swizzle Input Axis Values Useful to, for example, map 1D input signal for the W key to a Axis2D movement action. To World Space Auto-converts axes within the Input Action value into world space allowing the result to be directly plugged into functions that take world space values.E.g. for a 2D input axis up/down is mapped to world X (forward), whilst axis left/right is mapped to world Y (right)."},{"location":"player/input/#triggers","title":"Triggers","text":"<p>Triggers determine whether user input (after it has passed through the specified Modifiers), should activate the  corresponding Input Action. </p> <p>By default, any user activity on an input will trigger on every tick. However, Triggers allow you to analyze the  input, enabling you to check for minimum actuation values and validating patterns like short taps, prolonged holds, or the typical \"press\" or \"release\" events.</p> <p>To implement your own Triggers, you must inherit from the <code>UInputTrigger</code>  class. You then need to override the <code>UpdateState()</code> RPC, which must return an <code>ETriggerState</code> value.  The choices are:</p> <ul> <li><code>None</code>: Conditions have not been met, and the Input Action should not be activated.</li> <li><code>Ongoing</code>: Conditions are partially met, and the Trigger is ongoing but is not yet over the hill.</li> <li><code>Triggered</code>: Conditions have been fully met, and the Trigger has entered its final state.</li> </ul> <p>Another overridable method to consider is <code>GetTriggerType()</code>, returning an <code>ETriggerType</code>. This flag can be <code>Explicit</code>, <code>Implicit</code>, or <code>Blocker</code>. The trigger type only comes into play when multiple Triggers are assigned to the same Input Action. In such cases, the Input Action is triggered if:</p> <ul> <li>At least one <code>Explicit</code>-type Trigger fires.</li> <li>Every single <code>Implicit</code>-type Trigger fires.</li> <li>No <code>Blocker</code>-type Trigger fires.</li> </ul> <p>The following example shows a Trigger that fires once input has remained actuated (e.g., the button has remained pressed) for <code>HoldTimeThreshold</code> seconds.</p> UInputTriggerHold.h<pre><code>UCLASS(NotBlueprintable, MinimalAPI, meta = (DisplayName = \"Hold\"))\nclass UInputTriggerHold final : public UInputTriggerTimedBase {\n    GENERATED_BODY()\n\n    bool bTriggered = false;\n\nprotected:\n\n    virtual ETriggerState UpdateState_Implementation(const UEnhancedPlayerInput* PlayerInput, FInputActionValue ModifiedValue, float DeltaTime) override;\n\npublic:\n\n    virtual ETriggerEventsSupported GetSupportedTriggerEvents() const override { return ETriggerEventsSupported::Ongoing; }\n\n    // How long does the input have to be held to cause trigger?\n    UPROPERTY(EditAnywhere, Config, BlueprintReadWrite, Category = \"Trigger Settings\", meta = (ClampMin = \"0\"))\n    float HoldTimeThreshold = 1.0f;\n\n    // Should this trigger fire only once, or fire every frame once the hold time threshold is met?\n    UPROPERTY(EditAnywhere, Config, BlueprintReadWrite, Category = \"Trigger Settings\")\n    bool bIsOneShot = false;\n\n    virtual FString GetDebugState() const override { return HeldDuration ? FString::Printf(TEXT(\"Hold:%.2f/%.2f\"), HeldDuration, HoldTimeThreshold) : FString(); }\n};\n\"\n</code></pre> UInputTriggerHold.cpp<pre><code>ETriggerState UInputTriggerHold::UpdateState_Implementation(const UEnhancedPlayerInput* PlayerInput, FInputActionValue ModifiedValue, float DeltaTime) {\n    // Update HeldDuration and derive base state\n    ETriggerState State = Super::UpdateState_Implementation(PlayerInput, ModifiedValue, DeltaTime);\n\n    // Trigger when HeldDuration reaches the threshold\n    bool bIsFirstTrigger = !bTriggered;\n    bTriggered = HeldDuration &gt;= HoldTimeThreshold;\n\n    if (bTriggered) {\n        return (bIsFirstTrigger || !bIsOneShot) ? ETriggerState::Triggered : ETriggerState::None;\n    }\n    return State;\n} \n</code></pre>"},{"location":"player/input/#bundled_1","title":"Bundled","text":"<p>The following are the Triggers that come with the Enhanced Input Plugin out of the box.</p> Trigger Description Chorded Action Applies a Chord action that must be triggering for this trigger\u2019s action to trigger.E.g., in AC2, you are able to attack a guard by pressing the X, but this would only take place if you were already holding down right bumper to allow high profile actions. In Enhanced Input, you'll need to add this trigger to the attack action and set high profile as its Chord Action. Combo All actions in the Combo Actions array must be triggered to trigger the action this trigger is on. Actions must also be completed in the order specified by the combo actions array. This will only trigger for one frame before resetting the combo trigger\u2019s progress.Think of a double jump action that is triggered by pressing the space bar twice, or the combos in Street Fighter 6. Down Trigger fires when the input exceeds the Actuation Threshold.When there are no triggers bound, this is the default behavior (Threshold=0). Hold Trigger fires once input has remained actuated for Hold Time Threshold seconds.Trigger may optionally fire once, or repeatedly fire. Hold And Release Trigger fires when input is released after having been actuated for at least Hold Time Threshold seconds. Pressed Trigger fires once only when input exceeds the actuation threshold. Holding the input will not cause further triggers. Pulse Trigger that fires at an Interval, in seconds, while input is actuated. Released Trigger returns Ongoing whilst input exceeds the actuation threshold, and then fires once only when input drops back below the actuation threshold. Tap Input must be actuated and then released within Tap Release Time Threshold seconds to trigger."},{"location":"player/input/#mapping-contexts","title":"Mapping Contexts","text":"<p>Mapping Contexts bind hardware events to Input Actions. For example, you can associate WASD keys and the Gamepad Left Thumbstick movements with an Input Action for moving. You can assign additional Modifiers and Triggers to the Input Actions, as well. </p> <p></p> <p>Mapping Contexts can be added and removed at runtime. This makes it easier to manage a large number of Actions.  You can change how certain inputs behave depending on the current state of the player.</p> <p>As an example, you can give a character who can swim, walk, and drive vehicles multiple Input Mapping Contexts; one for common actions that are available and always mapped to the same user inputs, and another one for each individual mode  of travel. Developers can then place the vehicle-related Input Actions into a separate Input Mapping Context, which is  added to the local player when entering a vehicle, and removed from the local player when exiting the vehicle.</p> <p>You can add a Mapping Context to your Pawn / Character to the player in either C++:</p> Class Member Definition<pre><code>UPROPERTY(EditAnywhere, Category=\"Input\")\nTSoftObjectPtr&lt;UInputMappingContext&gt; InputMapping;\n</code></pre> BeginPlay()<pre><code>if (ULocalPlayer* LocalPlayer = Cast&lt;ULocalPlayer&gt;(Player)) {\n    if (UEnhancedInputLocalPlayerSubsystem* InputSystem = LocalPlayer-&gt;GetSubsystem&lt;UEnhancedInputLocalPlayerSubsystem&gt;()) {\n        if (!InputMapping.IsNull()) {\n            InputSystem-&gt;AddMappingContext(InputMapping.LoadSynchronous(), Priority);\n        }\n    }\n}\n</code></pre> <p>or Blueprints:</p> <p></p> <p>You can use <code>RemoveMappingContext()</code> or <code>ClearAllMappings()</code> to remove contexts dynamically.</p>"},{"location":"player/input/#input-listeners","title":"Input Listeners","text":"<p>After adding a Mapping Context to your Pawn / Character, you should be able to bind a callback function to each Input Action in C++:</p> <pre><code>// You should override SetupPlayerInputComponent() to set up input bindings.\nvoid AMyCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) {\n    UEnhancedInputComponent* Input = Cast&lt;UEnhancedInputComponent&gt;(PlayerInputComponent);\n    // You can bind to any of the trigger events here by changing the \"ETriggerEvent\" enum value\n    Input-&gt;BindAction(AimingInputAction, ETriggerEvent::Triggered, this, &amp;AFooBar::SomeCallbackFunc);\n}\n\nvoid AMyCharacter::SomeCallbackFunc(const FInputActionInstance&amp; Instance) {\n    // Get the value of the Input Action for whatever type you want here...\n    FVector VectorValue = Instance.GetValue().Get&lt;FVector&gt;();\n    FVector2D 2DAxisValue = Instance.GetValue().Get&lt;FVector2D&gt;();\n    float FloatValue = Instance.GetValue().Get&lt;float&gt;(); \n    bool BoolValue = Instance.GetValue().Get&lt;bool&gt;();\n    // Do your cool stuff here!\n} \n</code></pre> <p>or in Blueprints, by simply looking up the name of the Input Action:</p> <p>In either case, a triggered Input Action will have a Trigger State, which depends on the state and type of the assigned Triggers. The possible states are:</p> <ul> <li>Triggered: The action was triggered. This means that it has completed the evaluation of all trigger requirements. For example, a \"Press and Release\" trigger is sent when the user releases the key.</li> <li>Started: An event occurred that began trigger evaluation. For example, the first press of a \"Double tap\" trigger will call the \"Started\" state once.</li> <li>Ongoing: The trigger is still being processed. For example, a \"Press and hold\" action is ongoing while the user is holding down the button before the specified duration is reached. Depending on the triggers, this event will fire every tick while the action is evaluated once it receives an input value.</li> <li>Completed: The trigger evaluation process is completed.</li> <li>Canceled: The triggering was canceled. For example, a user lets go of a button before a \"Press and Hold\" action can be triggered.</li> </ul> <p>In C++, these states are represented by the <code>ETriggerEvent</code> enum, and are accessible via <code>FInputActionInstance.GetTriggerEvent()</code> in the callback function.</p>"},{"location":"player/input/#platform-setting","title":"Platform Setting","text":"<p>You may want different input settings for different platforms, such as rotating the face buttons on the Nintendo Switch  or altering the actions available on mobile devices. Enhanced Input provides a per-platform Mapping Context  Redirect that allows you to do this easily. Any time the mapping context is referenced on a specific platform,  it will be replaced by the value in the map when the mappings are rebuilt.</p> <p>In order to define your Mapping Context Redirects, you need to create a Blueprint, with <code>EnhancedInputPlatformData</code> as the parent class, for every platform. You can then specify which Mapping Context should be mapped to another  on the corresponding platform.</p> <p>After creating the blueprints, you need to head to Project Settings \u2192 Engine \u2192 Enhanced Input \u2192 Platform Settings to then set the associated Redirect for each platform.</p>"},{"location":"player/input/#debugging","title":"Debugging","text":"<p>Enhanced Input offers a few commands to help you debug your input mappings. </p> <p>By entering <code>showdebug enhancedinput</code> in the console, Unreal Engine will show you the state of every relevant  Input Action and their associated hardware inputs, allowing to debug your bindings:</p> <p></p> <p>You also have the option of debugging your connected input devices by using <code>showdebug devices</code>:</p> <p></p>"},{"location":"player/input/#injecting-input","title":"Injecting Input","text":"<p>Enhanced Input also brings along the concept of Injecting Input to your player. This option allows you to simulate  hardware input. You must use the <code>Input.+key</code> command to start simulating input and <code>Input.-key</code> to stop it.</p> <p>Below is an example of setting the <code>Gamepad_Left2D</code> key:</p> <pre><code>Input.+key Gamepad_Left2D X=0.7 Y=0.5\nInput.-key Gamepad_Left2D\n</code></pre> <p>You can find the names of hardware inputs in <code>InputCoreTypes.cpp</code>.</p> <p>You also have the option of injecting input to the player in C++:</p> <pre><code>UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem&lt;UEnhancedInputLocalPlayerSubsystem&gt;(PC-&gt;GetLocalPlayer());\nUEnhancedPlayerInput* PlayerInput = Subsystem-&gt;GetPlayerInput();\nFInputActionValue ActionValue(1.0f); // This can be a bool, float, FVector2D, or FVector\nPlayerInput-&gt;InjectInputForAction(InputAction, ActionValue); \n</code></pre> <p>and Blueprints:</p> <p></p>"},{"location":"tutorials/","title":"Unreal Engine 5 Tutorials","text":"<p>Here you can find a curated set of tutorials for Unreal Engine 5, adhering to best practices and using the latest  features. Tutorials may link related pieces of documentation for further reading. </p> <p>You can use the search bar at the top to look for a certain topic or mechanism you'd like to learn more about, or  navigate through the tutorials using the left sidebar.</p>"}]}